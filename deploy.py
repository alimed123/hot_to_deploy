# AUTOGENERATED! DO NOT EDIT! File to edit: Alejia_v1.10.ipynb.

# %% auto 0
__all__ = []

# %% Alejia_v1.10.ipynb 3
import os
os.environ['NEOS_EMAIL'] = 'aham225.driver@gmail.com'

# %% Alejia_v1.10.ipynb 9
from datetime import datetime

import streamlit as st
import seaborn as sns

from streamlit_jupyter import StreamlitPatcher, tqdm

counter = 0 #FIX

#currency = 'GBP'
#engmnt_kpi = 'views'

engmnt_kpi = st.text_input("What is your engagement KPI?",'views',key=counter)
counter=counter+1 #FIX


# %% Alejia_v1.10.ipynb 10
n = st.text_input("How many programs/channels are you planning to have?",'2',key=counter)
n = int(n)
counter=counter+1 #FIX

# %% Alejia_v1.10.ipynb 11
m = st.text_input("How many segments are there in your targeted audience?",'2',key=counter)
m = int(m)
counter=counter+1 #FIX

currency = st.text_input("What is your currency?",'GBP',key=counter)
counter=counter+1 #FIX

# %% Alejia_v1.10.ipynb 13
channels = []
categories = []
cost = {}
cnsrt = {}
x = {}
for j in range(m):
  categories.append(st.text_input("Enter the name of target category {}".format(str(j+1)),'category{}'.format(str(j+1),key=counter)))
  counter=counter+1
for i in range(n):
  channels.append(st.text_input("Enter the name of program/channel {}".format(str(i+1)),'channel{}'.format(str(i+1),key=counter)))
  counter=counter+1
  cost.update({i+1: int(st.text_input(f"Enter the cost in {currency}",'2000',key=counter))})
  counter=counter+1
  cnsrt.update({i+1: int(st.text_input(f"Enter specific minimum number/amount of {engmnt_kpi} for {channels[i]} (channel {i+1})",'200',key=counter))})
  counter=counter+1
  x.update({i+1:{}}) #FIX
  for j in range(m):
    x[i+1].update({j+1: int(st.text_input(f"Enter the current number/amount of {engmnt_kpi} from {categories[j]} (category {j+1}) at {channels[i]} (channel {i+1})",'50',key=counter))})
    counter=counter+1

# %% Alejia_v1.10.ipynb 15
# if len(channels)==0:
#   channels = ['Facebook', 'Instagram', 'Email', 'Youtube', 'Twitter', 'TikTok']

selected_channels = st.multiselect(
    "Selected marketing programs/channels: ",
    options=[channel for channel in channels],
    default=[channel for channel in channels]) #key = range(len(channels))

# %% Alejia_v1.10.ipynb 16
budget = st.text_input("What's your budget?",'10000', key=counter)
budget = int(budget)

# %% Alejia_v1.10.ipynb 17
from pyomo.environ import *

#Define the data
# n = 2 # comment when export, number of channels
# m = 2 # comment when export, number of audience marketing segments
# cost = {1: 50, 2: 70} # comment when export, cost per channel
# cnsrt = {1: 28, 2: 20}# comment when export, minimum number of views per channel
# x = {1: {1: 10, 2: 8}, 2: {1: 6, 2: 12}}# comment when export, current number of views per channels
# budget = 10000 # comment when export, total budget

# Create the model
model = ConcreteModel()

y = model.Var(range(1,n+1), domain=Binary)

# Define the decision variables
model.x = Var(range(1, n+1), domain=NonNegativeReals)

# Define the objective function
model.cost = Objective(expr=sum(cost[i] * model.x[i] for i in range(1, n+1)), sense=minimize)

# Define the constraints
model.constraints = ConstraintList()
for i in range(1, n+1):
    model.constraints.add(sum(x[i][j] * model.x[i] for j in range(1, m+1)) >= cnsrt[i])
model.constraints.add(expr=sum(cost[i]*model.x[i] for i in range(1, n+1)) <= budget)

# Solve the model
opt = SolverFactory('cbc')  # Select solver
solver_manager = SolverManagerFactory('neos')  # Solve in neos server
results = solver_manager.solve(model, opt=opt)

# Print the results
df = []
if str(results.solver.termination_condition) == "optimal":
  #print(f"Minimum cost: ${model.cost():,.2f}")
  for i in range(1, n+1):
    #print(f"Number of purchases/packages for {channels[i]}: {model.x[i]():,.0f}")
    df.append({'Channel': channels[i-1], 'Optimal Budget ({})'.format(currency): cost[i]*model.x[i]()})
else:
    st.write("Solver did not find an optimal solution. Please increase your budget and/or relax your constraints")


if str(results.solver.termination_condition) == "optimal":
	import pandas as pd

	st.caption("Minimum cost\n\n")

	st.write(f"{model.cost():,.2f} {currency}")

	st.caption("Marketing Optimal Budget Plan\n\n")
	st.write(pd.DataFrame(df))

	# %% Alejia_v1.10.ipynb 19
	# Pie Chart Visualisation

	import matplotlib.pyplot as plt

	# Pie chart, where the slices will be ordered and plotted counter-clockwise:
	labels = [channel for channel in channels]
	sizes = [model.x[i]() for i in range(1,len(model.x)+1)]
	# explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice

	st.caption('Recommended optimal budget distribution')

	import plotly.express as px
	import pandas as pd
	df = pd.DataFrame(sizes)
	df['size'] = df[0]
	for i in df.index:
		df.loc[i,'label'] = labels[i]
	grad = 0.125
	pie_chart = px.pie(df, 
				values='size', 
				names='label', 
				color='label', 
				color_discrete_map={labels[i]:'rgba({}, {}, {}, {})'.format(str(243*(1+grad*i)),str(73*(1+grad*i)),str(49*(1+grad*i)),str(0.73*(1+grad*i))) for i in range(len(labels))}, 
				)

	st.plotly_chart(pie_chart)

#	fig1, ax1 = plt.subplots()
#	fig1.patch.set_facecolor('blue')
#	fig1.patch.set_alpha(0)
#	# ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',
#	#         shadow=True, startangle=90)
#	ax1.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
#	ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
#	ax1.set(title="Budget distribution across channels")

#	st.pyplot(fig1)

	# %% Alejia_v1.10.ipynb 22
	# Bar chart visualisation

	import matplotlib.pyplot as plt

	dt_old_views = pd.DataFrame([x[i] for i in list(x)]) #index=x.keys()

	dt_new_views = {}
	for i in range(n):
		dt_new_views.update({channels[i]:{}})
		for j in range(m):
			dt_new_views[channels[i]].update({categories[j]: int(x[i+1][j+1] * model.x[i+1]())})

	dt_new_views = pd.DataFrame([dt_new_views[i] for i in list(dt_new_views)]) #index=dt_new_views.keys()

	dt_new_views.columns = categories
	dt_old_views.columns = categories

	for i in dt_old_views.index:
		dt_old_views.loc[i,'channel'] = channels[i]

	for i in dt_new_views.index:
		dt_new_views.loc[i,'channel'] = channels[i]

	#.plot(kind='bar', stacked=True, color=['red', 'pink'])

	#fig1 = dt_old_views.plot(kind='bar', stacked=True, transparent = True) #color=['red', 'pink']
	#fig2 = dt_new_views.plot(kind='bar', stacked=True, transparent = True) #color=['red', 'pink']


	# %% Alejia_v1.10.ipynb 23
	
	# Current views
	st.caption(f"Current {engmnt_kpi} summary\n\n")
	#set seaborn plotting aesthetics
	sns.set_style('white', {'axes.grid' : False}) # ("whitegrid", {'axes.grid' : False})
	st.bar_chart(dt_old_views, x='channel',y=categories)

	# Future views chart
	st.caption(f"Future {engmnt_kpi} summary\n\n")
	st.bar_chart(dt_new_views,  x='channel',y=categories)
